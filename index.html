<!DOCTYPE html>

<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">

    <title>Hsiang-Shang ‘Josh’ Ko (柯向上)</title>

    <link rel="icon" type="image/png" href="images/favicon.png">

    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

    <!-- Optional theme -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous">

    <!-- jQuery -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <!-- Latest compiled and minified JavaScript -->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

    <link href="https://fonts.googleapis.com/css?family=Open+Sans:400,600" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
  </head>

  <body>

    <div>
    <div class="container main">
      <div class="row">
        <div class="col-sm-9 header">
          <h1 class="name"><span class="line">Hsiang-Shang</a> <span class="line">‘Josh’ Ko</span> <span class="line">(柯向上)</span></h1>
          <p>Project Researcher</p>
          <p><a href="http://www.prg.nii.ac.jp">Programming Research Laboratory</a></p>
          <p><a href="http://www.nii.ac.jp">National Institute of Informatics</a></p>
          <p>Room 1611, 2-1-2 Hitotsubashi, Chiyoda-ku, Tōkyō 101-8430, Japan</p>
          <p>hsiang-shang@nii.ac.jp</p>
        </div>
        <div class="col-sm-3 photo">
          <img src="images/DPhil.png" width="200px" height="200px" alt="Photo">
        </div>
      </div>

      <div class="row section">
        <div class="col-sm-3">
          <h2 class="section-title">Research</h2>
        </div>
        <div class="col-sm-9">
          <p>I am interested in the discovery of logical structures of computation so that they can be manifested in programming languages and effectively guide the programmer. I approach problems mainly from the perspective of <a href="https://en.wikipedia.org/wiki/Intuitionistic_type_theory">intuitionistic type theory</a> or, in general, <a href="https://en.wikipedia.org/wiki/Functional_programming">functional programming</a>, occasionally aided by lightweight <a href="https://en.wikipedia.org/wiki/Category_theory">category theory</a>. For theoretic modelling, my weapon of choice is <a href="http://wiki.portal.chalmers.se/agda/pmwiki.php">Agda</a>; for practical programming, I use <a href="https://www.haskell.org">Haskell</a>.</p>
          <p>My current focus is on <em>bidirectional programming</em> for dealing with synchronisation — or consistency maintenance — problems. So far my results are built around the small bidirectional programming language BiGUL, which is hosted on <a href="https://bitbucket.org/prl_tokyo/bigul">Bitbucket</a> and available on <a href="https://hackage.haskell.org/package/BiGUL">Hackage</a>. The ultimate goal is to bring the form of and support for bidirectional programming closer to general-purpose programming, so that bidirectional programming techniques can be developed and applied in a wide variety of real-world synchronisation scenarios.
          </p>
          <p>Before coming to <a href="http://www.nii.ac.jp">NII</a>, I explored the potential of <a href="https://en.wikipedia.org/wiki/Dependent_type">dependently typed programming</a> for writing precisely typed programs such that their correctness is manifest in themselves and mechanically verifiable by typechecking. This is made possible primarily because of <a href="https://ncatlab.org/nlab/show/inductive+family">inductive families</a>, and my DPhil thesis developed <a
            href="https://en.wikipedia.org/wiki/Generic_programming#Functional_languages">datatype-generic</a> techniques for improving usability and reusability of inductive families. I also studied the Algebra of Programming (a.k.a. <a href="https://en.wikipedia.org/wiki/Bird–Meertens_formalism">Bird–Meertens formalism</a> or program calculation) and its formalisation using dependent types.</p>
          <p class="expertise-list">
            <span class="label expertise">Dependently typed programming</span>
            <span class="label expertise">Bidirectional programming</span>
            <span class="label expertise">Algebra of Programming</span>
            <span class="label expertise">Functional programming</span>
          </p>
        </div>
      </div>

      <div class="row section">
        <div class="col-sm-3">
          <h2 class="section-title">Biography</h2>
        </div>
        <div class="col-sm-9">
          <p>I was born and grew up in <a href="https://en.wikipedia.org/wiki/Taiwan">Taiwan</a>. After completing my undergraduate study and finishing the compulsory substitute service, I went to the UK for my DPhil degree (supervised by <a href="http://www.cs.ox.ac.uk/jeremy.gibbons/">Jeremy Gibbons</a>) and then came to Japan in 2014 to do postdoctoral research with <a href="http://research.nii.ac.jp/~hu/">Zhenjiang Hu</a> at <a href="http://www.nii.ac.jp">NII</a>. I’ve stayed here since then.</p>
          <p>My Chinese name 向上 (Hsiang-Shang) means “upwards” and is an unusual one; sadly, it’s impossible to approximate its pronunciation acceptably accurately in English. On the other hand, “Josh” is a name I’ve used for years (since 1996, to be precise), so I am perfectly happy (in fact happier) to be called by the name in English. (It turns out that “Hsiang-Shang” is also difficult for Japanese people to pronounce, and my Japanese colleagues are happier to call me “Josh” too.)</p>
          <p>I listen to classical music (mainly from the Romantic period) and play the piano — I now own a Kawai CA65 digital piano, and strive to practise daily. For piano music, I feel closest to Chopin, but I’m also getting to know Beethoven and Schubert. More broadly, I also admire Brahms and Tchaikovsky.</p>
          <p>Recently I’m attracted to <a href="http://www.airliners.net/forum/viewforum.php?f=5">technical and operational aspects of civil aviation</a>; I collect 1/200 and 1/400 airliner models, and I’m learning to “fly” the <a href="https://en.wikipedia.org/wiki/Boeing_777">Boeing 777</a> in <a href="http://www.x-plane.com">X-Plane</a>.</p>
        </div>
      </div>

      <div class="row section">
        <div class="col-sm-3">
          <h2 class="section-title">Education</h2>
        </div>
        <div class="col-sm-9">

          <dl>

            <dt>DPhil in <a href="http://www.cs.ox.ac.uk">Computer Science</a></dt>
            <dd><a href="http://www.ox.ac.uk">University of Oxford</a> (2010–2014)</dd>

            <dt>BSc in <a href="https://www.csie.ntu.edu.tw">Computer Science and Information Engineering</a></dt>
            <dd><a href="http://www.ntu.edu.tw">National Taiwan University</a> (2005–2009)</dd>

          </dl>

        </div>
      </div>

      <div class="row section">
        <div class="col-sm-3">
          <h2 class="section-title">Roles</h2>
        </div>
        <div class="col-sm-9">

          <dl>

            <dt>Workshop on Partial Evaluation and Program Manipulation (PEPM) 2018</dt>
            <dd>Programme committee co-chair</dd>

            <dt><a href="http://www.info.kochi-tech.ac.jp/FLOPS2016/">International Symposium on Functional and Logic Programming (FLOPS) 2016</a></dt>
            <dd>Programme committee member</dd>

            <dt><a href="http://flolac.iis.sinica.edu.tw">Formosan Summer School on Logic, Language, and Computation (FLOLAC)</a></dt>
            <dd>Organising committee member (2016–)<br>
                Lecturer (2012–)</dd>

          </dl>

        </div>
      </div>

      <div class="row section">
        <div class="col-sm-3">
          <h2 class="section-title">Publications & manuscripts</h2>
        </div>
        <div class="col-sm-9">

          <div class="publication">
            <div class="publication-title">
              Palgol: A high-level DSL for vertex-centric graph processing with remote data access
            </div>
            <div class="publication-authors">
              <a href="http://zyz915.github.io">Yongzhe Zhang</a>, Hsiang-Shang Ko, and <a href="http://research.nii.ac.jp/~hu/">Zhenjiang Hu</a>
            </div>
            <div class="publication-venue">
              <a href="https://arxiv.org">arXiv</a><span class="publication-year">2017</span>
            </div>
            <div class="publication-links">
              <span class="label label-danger publication-type">Technical report</span>
              <span class="label label-primary"><a href="https://arxiv.org/pdf/1703.09542">PDF (arXiv)</a></span>
              <span class="label label-primary"><a href="https://bitbucket.org/zyz915/palgol">Repository (Bitbucket)</a></span>
              <span class="label label-info publication-more-info" data-toggle="collapse" data-target="#Palgol-arXiv17">More info</span>
            </div>
          </div>
          <div class="panel panel-publication-info collapse" id="Palgol-arXiv17">
            <div class="panel-body">
              <div class="row publication-info">
                <div class="col-sm-2 publication-info-title">
                  arXiv
                </div>
                <div class="col-sm-10">
                  <a href="https://arxiv.org/abs/1703.09542">1703.09542</a>
                </div>
              </div>
              <div class="row publication-info">
                <div class="col-sm-2 publication-info-title">
                  Abstract
                </div>
                <div class="col-sm-10">
                  <p>Pregel is a popular parallel computing model for dealing with large-scale graphs. However, it can be tricky to implement graph algorithms correctly and efficiently in Pregel’s vertex-centric model, as programmers need to carefully restructure an algorithm in terms of supersteps and message passing, which are low-level and detached from the algorithm descriptions. Some domain-specific languages (DSLs) have been proposed to provide more intuitive ways to implement graph algorithms, but none of them can flexibly describe remote access (reading or writing attributes of other vertices through references), causing a still wide range of algorithms hard to implement.</p>
                  <p>To address this problem, we design and implement Palgol, a more declarative and powerful DSL which supports remote access. In particular, programmers can use a more declarative syntax called <em>global field access</em> to directly read data on remote vertices. By structuring supersteps in a high-level vertex-centric computation model and analyzing the logic patterns of global field access, we provide a novel algorithm for compiling Palgol programs to efficient Pregel code. We demonstrate the power of Palgol by using it to implement a bunch of practical Pregel algorithms and compare them with hand-written code. The evaluation result shows that the efficiency of Palgol is comparable with that of hand-written code.</p>
                </div>
              </div>
            </div>
          </div>

          <div class="publication">
            <div class="publication-title">
              An axiomatic basis for bidirectional programming
            </div>
            <div class="publication-authors">
              Hsiang-Shang Ko and <a href="http://research.nii.ac.jp/~hu/">Zhenjiang Hu</a>
            </div>
            <div class="publication-venue">
              In submission<span class="publication-year">2017</span>
            </div>
            <div class="publication-links">
              <span class="label label-danger publication-type">Draft manuscript</span>
              <span class="label label-primary"><a href="publications/BiGUL-logic.pdf">PDF (draft)</a></span>
              <span class="label label-primary"><a href="https://bitbucket.org/prl_tokyo/bigul/src/logic/Agda/">Agda code (Bitbucket)</a></span>
              <span class="label label-info publication-more-info" data-toggle="collapse" data-target="#BiGUL-logic">More info</span>
            </div>
          </div>
          <div class="panel panel-publication-info collapse" id="BiGUL-logic">
            <div class="panel-body">
              <div class="row publication-info">
                <div class="col-sm-2 publication-info-title">
                  Abstract
                </div>
                <div class="col-sm-10">
                  <p>Among the frameworks of bidirectional transformations proposed for addressing various synchronisation problems, Foster et al.’s asymmetric lenses have influenced the design of a generation of bidirectional programming languages. Most of these languages are highly declarative, and only allow the programmer to specify a consistency relation with limited control over the behaviour of the automatically derived consistency restorer. However, synchronisation problems are diverse and require vastly different consistency restoration strategies, and to cope with the diversity, the programmer must be empowered to fully control and reason about the consistency restoration behaviour of their bidirectional programs. The putback-based approach to bidirectional programming was proposed to address this issue once and for all, and this paper takes the approach one step further by proposing a Hoare-style logic for Ko et al.’s putback-based language BiGUL. With this Hoare-style logic, the BiGUL programmer can precisely characterise the bidirectional behaviour of their programs by reasoning solely in the putback direction. The theory underlying the Hoare-style logic has been formalised and checked in Agda, but this paper presents the Hoare-style logic in a semi-formal way to make it easily understood and usable by the working BiGUL programmer.</p>
                </div>
              </div>
            </div>
          </div>

          <div class="publication">
            <div class="publication-title">
              BenchmarX reloaded: A practical benchmark framework for bidirectional transformations
            </div>
            <div class="publication-authors">
              <a href="http://is.uni-paderborn.de/index.php?id=14962">Anthony Anjorin</a>, <a href="http://www.cs.toronto.edu/~zdiskin/">Zinovy Diskin</a>, <a href="http://www.eseo.fr/annuaire-du-personnel/entry-5239-jouault-frederic.html">Frédéric Jouault</a>, Hsiang-Shang Ko, <a href="http://www.es.tu-darmstadt.de/es/team/erhan-leblebici/">Erhan Leblebici</a>, and <a href="http://www.ai1.uni-bayreuth.de/en/team/Westfechtel_Bernhard/">Bernhard Westfechtel</a>
            </div>
            <div class="publication-venue">
              <a href="http://bx-community.wikidot.com/bx2017:home">International Workshop on Bidirectional Transformations (BX)<span class="publication-year">2017</span></a>
            </div>
            <div class="publication-links">
              <span class="label label-default publication-type">In preparation for publication</span>
            </div>
          </div>

          <div class="publication">
            <div class="publication-title">
              Principle and practice of bidirectional programming in BiGUL
            </div>
            <div class="publication-authors">
              <a href="http://research.nii.ac.jp/~hu/">Zhenjiang Hu</a> and Hsiang-Shang Ko
            </div>
            <div class="publication-venue">
              <a href="https://www.cs.ox.ac.uk/projects/tlcbx/ssbx/">Oxford Summer School on Bidirectional Transformations</a><span class="publication-year">2017</span>
            </div>
            <div class="publication-links">
              <span class="label label-danger publication-type">Draft manuscript</span>
              <span class="label label-primary"><a href="https://bitbucket.org/prl_tokyo/bigul/raw/master/SummerSchool16/paper/BiGUL_tutorial.pdf">PDF (Bitbucket)</a></span>
              <span class="label label-primary"><a href="https://bitbucket.org/prl_tokyo/bigul">Repository (Bitbucket)</a></span>
              <span class="label label-info publication-more-info" data-toggle="collapse" data-target="#BiGUL-tutorial">More info</span>
            </div>
          </div>
          <div class="panel panel-publication-info collapse" id="BiGUL-tutorial">
            <div class="panel-body">
              <div class="row publication-info">
                <div class="col-sm-2 publication-info-title">
                  Abstract
                </div>
                <div class="col-sm-10">
                  <p>Putback-based bidirectional programming allows the programmer to write only one putback transformation, from which the unique corresponding forward transformation is derived for free. A key distinguishing feature of putback-based bidirectional programming is full control over the bidirectional behavior, which is important for specifying intended bidirectional transformations without any ambiguity. In this tutorial, we will introduce BiGUL, a simple yet powerful putback-based bidirectional programming language, explaining the underlying principles and showing how various kinds of bidirectional applications can be developed in BiGUL.</p>
                </div>
              </div>
            </div>
          </div>

          <div class="publication">
            <div class="publication-title">
              Programming with ornaments
            </div>
            <div class="publication-authors">
              Hsiang-Shang Ko and <a href="http://www.cs.ox.ac.uk/jeremy.gibbons/">Jeremy Gibbons</a>
            </div>
            <div class="publication-venue">
              <a href="https://www.cambridge.org/core/journals/journal-of-functional-programming">Journal of Functional Programming</a><span class="publication-year">2017</span>
            </div>
            <div class="publication-links">
              <span class="label label-primary"><a href="publications/OrnJFP.pdf">PDF (preprint)</a></span>
              <span class="label label-primary"><a href="https://www.cambridge.org/core/journals/journal-of-functional-programming/article/programming-with-ornaments/97C63D7C90556ACD2EC1482E63026A74#fndtn-supplementary-materials">Agda code (JFP)</a></span>
              <span class="label label-info publication-more-info" data-toggle="collapse" data-target="#JFP17">More info</span>
            </div>
          </div>
          <div class="panel panel-publication-info collapse" id="JFP17">
            <div class="panel-body">
              <div class="row publication-info">
                <div class="col-sm-2 publication-info-title">
                  Volume
                </div>
                <div class="col-sm-10">
                  27
                </div>
              </div>
              <div class="row publication-info">
                <div class="col-sm-2 publication-info-title">
                  Issue
                </div>
                <div class="col-sm-10">
                  e2
                </div>
              </div>
              <div class="row publication-info">
                <div class="col-sm-2 publication-info-title">
                  Pages
                </div>
                <div class="col-sm-10">
                  1–43
                </div>
              </div>
              <div class="row publication-info">
                <div class="col-sm-2 publication-info-title">
                  DOI
                </div>
                <div class="col-sm-10">
                  <a href="http://dx.doi.org/10.1017/S0956796816000307">10.1017/S0956796816000307</a>
                </div>
              </div>
              <div class="row publication-info">
                <div class="col-sm-2 publication-info-title">
                  Abstract
                </div>
                <div class="col-sm-10">
                  <p>Dependently typed programming advocates the use of various indexed versions of the same shape of data, but the formal relationship amongst these structurally similar datatypes usually needs to be established manually and tediously. Ornaments have been proposed as a formal mechanism to manage the relationships between such datatype variants. In this paper, we conduct a case study under an ornament framework; the case study concerns programming binomial heaps and their operations — including insertion and minimum extraction — by viewing them as lifted versions of binary numbers and numeric operations. We show how current dependently typed programming technology can lead to a clean treatment of the binomial heap constraints when implementing heap operations. We also identify some gaps between the current technology and an ideal dependently typed programming language that we would wish to have for our development.</p>
                </div>
              </div>
            </div>
          </div>

          <div class="publication">
            <div class="publication-title">
              Parsing and reflective printing, bidirectionally
            </div>
            <div class="publication-authors">
              <a href="http://www.prg.nii.ac.jp/members/zhu/">Zirun Zhu</a>, <a href="http://zyz915.github.io">Yongzhe Zhang</a>, Hsiang-Shang Ko, <a href="https://isr.uci.edu/users/pedro-ribeiro-martins">Pedro Martins</a>, <a href="http://haslab.uminho.pt/jas/">João Saraiva</a>, and <a href="http://research.nii.ac.jp/~hu/">Zhenjiang Hu</a>
            </div>
            <div class="publication-venue">
              <a href="http://www.sleconf.org/2016/">International Conference on Software Language Engineering (SLE)<span class="publication-year">2016</span></a>
            </div>
            <div class="publication-links">
              <span class="label label-primary"><a href="https://dl.acm.org/authorize?N21371">PDF (ACM Author-Izer)</a></span>
              <span class="label label-primary"><a href="http://biyacc.yozora.moe">Demo site</a></span>
              <span class="label label-info publication-more-info" data-toggle="collapse" data-target="#SLE16">More info</span>
            </div>
          </div>
          <div class="panel panel-publication-info collapse" id="SLE16">
            <div class="panel-body">
              <div class="row publication-info">
                <div class="col-sm-2 publication-info-title">
                  Pages
                </div>
                <div class="col-sm-10">
                  2–14
                </div>
              </div>
              <div class="row publication-info">
                <div class="col-sm-2 publication-info-title">
                  DOI
                </div>
                <div class="col-sm-10">
                  <a href="http://dx.doi.org/10.1145/2997364.2997369">10.1145/2997364.2997369</a>
                </div>
              </div>
              <div class="row publication-info">
                <div class="col-sm-2 publication-info-title">
                  Abstract
                </div>
                <div class="col-sm-10">
                  <p>Language designers usually need to implement parsers and printers. Despite being two intimately related programs, in practice they are often designed separately, and then need to be revised and kept consistent as the language evolves. It will be more convenient if the parser and printer can be unified and developed in one single program, with their consistency guaranteed automatically.</p>
                  <p>Furthermore, in certain scenarios (like showing compiler optimisation results to the programmer), it is desirable to have a more powerful <em>reflective</em> printer that, when an abstract syntax tree corresponding to a piece of program text is modified, can reflect the modification to the program text while preserving layouts, comments, and syntactic sugar.</p>
                  <p>To address these needs, we propose a domain-specific language BiYacc, whose programs denote both a parser and a reflective printer for an unambiguous context-free grammar. BiYacc is based on the theory of <em>bidirectional transformations</em>, which helps to guarantee by construction that the pairs of parsers and reflective printers generated by BiYacc are consistent. We show that BiYacc is capable of facilitating many tasks such as Pombrio and Krishnamurthi’s “resugaring”, language evolution, and refactoring.</p>
                </div>
              </div>
            </div>
          </div>

          <div class="publication">
            <div class="publication-title">
              The under-appreciated put: Implementing delta-alignment in BiGUL
            </div>
            <div class="publication-authors">
              <a href="http://wiki.di.uminho.pt/twiki/bin/view/Personal/JorgeMendes/WebHome">Jorge Mendes</a>, Hsiang-Shang Ko, and <a href="http://research.nii.ac.jp/~hu/">Zhenjiang Hu</a>
            </div>
            <div class="publication-venue">
              <a href="http://grace-center.jp">GRACE Center, National Institute of Informatics</a><span class="publication-year">2016</span>
            </div>
            <div class="publication-links">
              <span class="label label-danger publication-type">Technical report</span>
              <span class="label label-primary"><a href="http://grace-center.jp/wp-content/uploads/2016/04/GRACE-TR-2016-03.pdf">PDF (GRACE Center)</a></span>
              <span class="label label-info publication-more-info" data-toggle="collapse" data-target="#GRACE16">More info</span>
            </div>
          </div>
          <div class="panel panel-publication-info collapse" id="GRACE16">
            <div class="panel-body">
              <div class="row publication-info">
                <div class="col-sm-2 publication-info-title">
                  Number
                </div>
                <div class="col-sm-10">
                  GRACE-TR 2016-03
                </div>
              </div>
              <div class="row publication-info">
                <div class="col-sm-2 publication-info-title">
                  URL
                </div>
                <div class="col-sm-10">
                  <a href="http://grace-center.jp/wp-content/uploads/2016/04/GRACE-TR-2016-03.pdf">http://grace-center.jp/wp-content/uploads/2016/04/GRACE-TR-2016-03.pdf</a>
                </div>
              </div>
              <div class="row publication-info">
                <div class="col-sm-2 publication-info-title">
                  Abstract
                </div>
                <div class="col-sm-10">
                  <p>There are two approaches to bidirectional programming. One is the get-based method where one writes <em>get</em> and <em>put</em> is automatically derived, and the other is the put-based method where one writes <em>put</em> and <em>get</em> is automatically derived. In this paper, we argue that the put-based method deserves more attention, because a good language for programming <em>put</em> can not only give full control over the behavior of bidirectional transformations, but also enable us to efficiently develop various domain-specific bidirectional languages and use them seamlessly in one framework, which would be non-trivial with the get-based method. We demonstrate how the matching/delta/generic lenses can be implemented in BiGUL, a putback-based bidirectional language.</p>
                </div>
              </div>
            </div>
          </div>

          <div class="publication">
            <div class="publication-title">
              Brul: A putback-based bidirectional transformation library for updatable views
            </div>
            <div class="publication-authors">
              <a href="http://stefanzan.com">Tao Zan</a>, Li Liu, Hsiang-Shang Ko, and <a href="http://research.nii.ac.jp/~hu/">Zhenjiang Hu</a>
            </div>
            <div class="publication-venue">
              <a href="http://bx-community.wikidot.com/bx2016:home">International Workshop on Bidirectional Transformations (BX)<span class="publication-year">2016</span></a>
            </div>
            <div class="publication-links">
              <span class="label label-primary"><a href="http://ceur-ws.org/Vol-1571/paper_3.pdf">PDF (CEUR-WS)</a></span>
              <span class="label label-info publication-more-info" data-toggle="collapse" data-target="#BX16">More info</span>
            </div>
          </div>
          <div class="panel panel-publication-info collapse" id="BX16">
            <div class="panel-body">
              <div class="row publication-info">
                <div class="col-sm-2 publication-info-title">
                  Pages
                </div>
                <div class="col-sm-10">
                  77–89
                </div>
              </div>
              <div class="row publication-info">
                <div class="col-sm-2 publication-info-title">
                  URL
                </div>
                <div class="col-sm-10">
                  <a href="http://ceur-ws.org/Vol-1571/paper_3.pdf">http://ceur-ws.org/Vol-1571/paper_3.pdf</a>
                </div>
              </div>
              <div class="row publication-info">
                <div class="col-sm-2 publication-info-title">
                  Abstract
                </div>
                <div class="col-sm-10">
                  <p>In work on relational databases, the view-update problem is about how to translate update operations on the view table to corresponding update operations on the source table properly. It is a problem that the translation policies are not unique in many situations. Relational lenses try to solve this problem by providing a list of combinators that let the user write <em>get</em> functions (queries) with specified updated policies for <em>put</em> functions (updates); however this can only provide limited control of update policies which still may not satisfy the user’s real needs. In this paper, we implement a library Brul that provides putback-based basic combinators for the user to write the <em>put</em> function with flexible update policies easily; from the <em>put</em> function, a unique <em>get</em> function can be derived automatically. Brul is implemented in terms of BiGUL, a core bidirectional programming language which has been formalized in Agda and implemented as a Haskell library.</p>
                </div>
              </div>
            </div>
          </div>

          <div class="publication">
            <div class="publication-title">
              BiGUL: A formally verified core language for putback-based bidirectional programming 
            </div>
            <div class="publication-authors">
              Hsiang-Shang Ko, <a href="http://stefanzan.com">Tao Zan</a>, and <a href="http://research.nii.ac.jp/~hu/">Zhenjiang Hu</a>
            </div>
            <div class="publication-venue">
              <a href="http://conf.researchr.org/home/pepm-2016">Workshop on Partial Evaluation and Program Manipulation (PEPM)<span class="publication-year">2016</span></a>
            </div>
            <div class="publication-links">
              <span class="label label-primary"><a href="https://dl.acm.org/authorize?N21372">PDF (ACM Author-Izer)</a></span>
              <span class="label label-primary"><a href="https://bitbucket.org/prl_tokyo/bigul">Repository (Bitbucket)</a></span>
              <span class="label label-info publication-more-info" data-toggle="collapse" data-target="#PEPM16">More info</span>
            </div>
          </div>
          <div class="panel panel-publication-info collapse" id="PEPM16">
            <div class="panel-body">
              <div class="row publication-info">
                <div class="col-sm-2 publication-info-title">
                  Pages
                </div>
                <div class="col-sm-10">
                  61–72
                </div>
              </div>
              <div class="row publication-info">
                <div class="col-sm-2 publication-info-title">
                  DOI
                </div>
                <div class="col-sm-10">
                  <a href="http://dx.doi.org/10.1145/2847538.2847544">10.1145/2847538.2847544</a>
                </div>
              </div>
              <div class="row publication-info">
                <div class="col-sm-2 publication-info-title">
                  Abstract
                </div>
                <div class="col-sm-10">
                  <p>Putback-based bidirectional programming allows the programmer to write only one putback transformation, from which the unique corresponding forward transformation is derived for free. The logic of a putback transformation is more sophisticated than that of a forward transformation and does not always give rise to well-behaved bidirectional programs; this calls for more robust language design to support development of well-behaved putback transformations. In this paper, we design and implement a concise core language BiGUL for putback-based bidirectional programming to serve as a foundation for higher-level putback-based languages. BiGUL is completely formally verified in the dependently typed programming language Agda to guarantee that any putback transformation written in BiGUL is well-behaved.</p>
                </div>
              </div>
            </div>
          </div>

          <div class="publication">
            <div class="publication-title">
              BiYacc: Roll your parser and reflective printer into one
            </div>
            <div class="publication-authors">
              <a href="http://www.prg.nii.ac.jp/members/zhu/">Zirun Zhu</a>, Hsiang-Shang Ko, <a href="https://isr.uci.edu/users/pedro-ribeiro-martins">Pedro Martins</a>, <a href="http://haslab.uminho.pt/jas/">João Saraiva</a>, and <a href="http://research.nii.ac.jp/~hu/">Zhenjiang Hu</a>
            </div>
            <div class="publication-venue">
              <a href="http://bx-community.wikidot.com/bx2015:home">International Workshop on Bidirectional Transformations (BX)<span class="publication-year">2015</span></a>
            </div>
            <div class="publication-links">
              <span class="label label-primary"><a href="http://ceur-ws.org/Vol-1396/p43-zhu.pdf">PDF (CEUR-WS)</a></span>
              <span class="label label-primary"><a href="http://biyacc.yozora.moe">Demo site</a></span>
              <span class="label label-info publication-more-info" data-toggle="collapse" data-target="#BX15">More info</span>
            </div>
          </div>
          <div class="panel panel-publication-info collapse" id="BX15">
            <div class="panel-body">
              <div class="row publication-info">
                <div class="col-sm-2 publication-info-title">
                  Pages
                </div>
                <div class="col-sm-10">
                  43–50
                </div>
              </div>
              <div class="row publication-info">
                <div class="col-sm-2 publication-info-title">
                  URL
                </div>
                <div class="col-sm-10">
                  <a href="http://ceur-ws.org/Vol-1396/p43-zhu.pdf">http://ceur-ws.org/Vol-1396/p43-zhu.pdf</a>
                </div>
              </div>
              <div class="row publication-info">
                <div class="col-sm-2 publication-info-title">
                  Abstract
                </div>
                <div class="col-sm-10">
                  <p>Language designers usually need to implement parsers and printers. Despite being two related programs, in practice they are designed and implemented separately. This approach has an obvious disadvantage: as a language evolves, both its parser and printer need to be separately revised and kept synchronised. Such tasks are routine but complicated and error-prone. To facilitate these tasks, we propose a language called BiYacc, whose programs denote both a parser and a printer. In essence, BiYacc is a domain-specific language for writing <em>putback-based</em> bidirectional transformations — the printer is a putback transformation, and the parser is the corresponding get transformation. The pairs of parsers and printers generated by BiYacc are thus always guaranteed to satisfy the usual round-trip properties. The highlight that distinguishes this <em>reflective</em> printer from others is that the printer — being a putback transformation — accepts not only an abstract syntax tree but also a string, and produces an updated string consistent with the given abstract syntax tree. We can thus make use of the additional input string, with mechanisms such as simultaneous pattern matching on the view and the source, to provide users with full control over the printing-strategies.</p>
                </div>
              </div>
            </div>
          </div>

          <div class="publication">
            <div class="publication-title">
              Analysis and synthesis of inductive families
            </div>
            <div class="publication-authors">
              Hsiang-Shang Ko
            </div>
            <div class="publication-venue">
              <a href="http://www.ox.ac.uk">University of Oxford</a><span class="publication-year">2014</span>
            </div>
            <div class="publication-links">
              <span class="label label-success publication-type">DPhil dissertation</span>
              <span class="label label-primary"><a href="https://github.com/josh-hs-ko/dissertation/raw/master/dissertation.pdf">PDF (GitHub)</a></span>
              <span class="label label-primary"><a href="https://github.com/josh-hs-ko/Thesis">Agda code (GitHub)</a></span>
              <span class="label label-info publication-more-info" data-toggle="collapse" data-target="#DPhil">More info</span>
            </div>
          </div>
          <div class="panel panel-publication-info collapse" id="DPhil">
            <div class="panel-body">
              <div class="row publication-info">
                <div class="col-sm-2 publication-info-title">
                  URL
                </div>
                <div class="col-sm-10">
                  <a href="http://ora.ox.ac.uk/objects/ora:9019">http://ora.ox.ac.uk/objects/ora:9019</a>
                </div>
              </div>
              <div class="row publication-info">
                <div class="col-sm-2 publication-info-title">
                  Repository
                </div>
                <div class="col-sm-10">
                  <a href="https://github.com/josh-hs-ko/dissertation">https://github.com/josh-hs-ko/dissertation</a>
                </div>
              </div>
              <div class="row publication-info">
                <div class="col-sm-2 publication-info-title">
                  Abstract
                </div>
                <div class="col-sm-10">
                  <p>Based on a natural unification of logic and computation, Martin-Löf’s <em>intuitionistic type theory</em> can be regarded simultaneously as a computationally meaningful higher-order logic system and an expressively typed functional programming language, in which proofs and programs are treated as the same entities. Two modes of programming can then be distinguished: in <em>externalism</em>, we construct a program separately from its correctness proof with respect to a given specification, whereas in <em>internalism</em>, we encode the specification in a sophisticated type such that any program inhabiting the type also encodes a correctness proof, and we can use type information as a guidance on program construction. Internalism is particularly effective in the presence of <em>inductive families</em>, whose design can have a strong influence on program structure. Techniques and mechanisms for facilitating internalist programming are still lacking, however.</p>
                  <p>This dissertation proposes that internalist programming can be facilitated by exploiting an interconnection between internalism and externalism, expressed as isomorphisms between inductive families into which data structure invariants are encoded and their simpler variants paired with predicates expressing those invariants. The interconnection has two directions: one <em>analysing</em> inductive families into simpler variants and predicates, and the other <em>synthesising</em> inductive families from simpler variants and specific predicates. They respectively give rise to two applications, one achieving a modular structure of internalist libraries, and the other bridging internalist programming with relational specifications and program derivation. The datatype-generic mechanisms supporting the applications are based on McBride’s <em>ornaments</em>. Theoretically, the key ornamental constructs — <em>parallel composition of ornaments</em> and <em>relational algebraic ornamentation</em> — are further characterised in terms of lightweight category theory. Most of the results are completely formalised in the Agda programming language.</p>
                </div>
              </div>
            </div>
          </div>

          <div class="publication">
            <div class="publication-title">
              Relational algebraic ornaments
            </div>
            <div class="publication-authors">
              Hsiang-Shang Ko and <a href="http://www.cs.ox.ac.uk/jeremy.gibbons/">Jeremy Gibbons</a>
            </div>
            <div class="publication-venue">
              <a href="http://www.seas.upenn.edu/~sweirich/dtp13/">Workshop on Dependently Typed Programming (DTP)<span class="publication-year">2013</span></a>
            </div>
            <div class="publication-links">
              <span class="label label-primary"><a href="https://dl.acm.org/authorize?N21373">PDF (ACM Author-Izer)</a></span>
              <span class="label label-info publication-more-info" data-toggle="collapse" data-target="#algOrn">More info</span>
            </div>
          </div>
          <div class="panel panel-publication-info collapse" id="algOrn">
            <div class="panel-body">
              <div class="row publication-info">
                <div class="col-sm-2 publication-info-title">
                  Pages
                </div>
                <div class="col-sm-10">
                  37–48
                </div>
              </div>
              <div class="row publication-info">
                <div class="col-sm-2 publication-info-title">
                  DOI
                </div>
                <div class="col-sm-10">
                  <a href="http://dx.doi.org/10.1145/2502409.2502413">10.1145/2502409.2502413</a>
                </div>
              </div>
              <div class="row publication-info">
                <div class="col-sm-2 publication-info-title">
                  Abstract
                </div>
                <div class="col-sm-10">
                  <p>Dependently typed programming is hard, because ideally dependently typed programs should share structure with their correctness proofs, but there are very few guidelines on how one can arrive at such integrated programs. McBride’s algebraic ornamentation provides a methodological advancement, by which the programmer can derive a datatype from a specification involving a fold, such that a program that constructs elements of that datatype would be correct by construction. It is thus an effective method that leads the programmer from a specification to a dependently typed program. We enhance the applicability of this method by generalising algebraic ornamentation to a relational setting and bringing in relational algebraic methods, resulting in a hybrid approach that makes essential use of both dependently typed programming and relational program derivation. A dependently typed solution to the minimum coin change problem is presented as a demonstration of this hybrid approach. We also give a theoretically interesting “completeness theorem” of relational algebraic ornaments, which sheds some light on the expressive power of ornaments and inductive families.</p>
                </div>
              </div>
            </div>
          </div>

          <div class="publication">
            <div class="publication-title">
              Modularising inductive families
            </div>
            <div class="publication-authors">
              Hsiang-Shang Ko and <a href="http://www.cs.ox.ac.uk/jeremy.gibbons/">Jeremy Gibbons</a>
            </div>
            <div class="publication-venue">
              <a href="https://www.nii.ac.jp/pi/">Progress in Informatics</a><span class="publication-year">2013</span>
            </div>
            <div class="publication-links">
              <span class="label label-primary"><a href="http://www.nii.ac.jp/pi/n10/10_65.pdf">PDF (NII)</a></span>
              <span class="label label-info publication-more-info" data-toggle="collapse" data-target="#pcOrn">More info</span>
            </div>
          </div>
          <div class="panel panel-publication-info collapse" id="pcOrn">
            <div class="panel-body">
              <div class="row publication-info">
                <div class="col-sm-2 publication-info-title">
                  Number
                </div>
                <div class="col-sm-10">
                  10
                </div>
              </div>
              <div class="row publication-info">
                <div class="col-sm-2 publication-info-title">
                  Pages
                </div>
                <div class="col-sm-10">
                  65–88
                </div>
              </div>
              <div class="row publication-info">
                <div class="col-sm-2 publication-info-title">
                  DOI
                </div>
                <div class="col-sm-10">
                  <a href="http://dx.doi.org/10.2201/NiiPi.2013.10.5">10.2201/NiiPi.2013.10.5</a>
                </div>
              </div>
              <div class="row publication-info">
                <div class="col-sm-2 publication-info-title">
                  Abstract
                </div>
                <div class="col-sm-10">
                  <p>Dependently typed programmers are encouraged to use inductive families to integrate constraints with data construction. Different constraints are used in different contexts, leading to different versions of datatypes for the same data structure. For example, sequences might be constrained by length or by an ordering on elements, giving rise to different datatypes “vectors” and “sorted lists” for the same underlying data structure of sequences. Modular implementation of common operations for these structurally similar datatypes has been a longstanding problem. We propose a datatype-generic solution, in which we axiomatise a family of isomorphisms between datatypes and their more refined versions as datatype refinements, and show that McBride’s ornaments can be translated into such refinements. With the ornament-induced refinements, relevant properties of the operations can be separately proven for each constraint, and after the programmer selects several constraints to impose on a basic datatype and synthesises a new datatype incorporating those constraints, the operations can be routinely upgraded to work with the synthesised datatype.</p>
                </div>
              </div>
            </div>
          </div>

          <div class="publication">
            <div class="publication-title">
              Modularising inductive families
            </div>
            <div class="publication-authors">
              Hsiang-Shang Ko and <a href="http://www.cs.ox.ac.uk/jeremy.gibbons/">Jeremy Gibbons</a>
            </div>
            <div class="publication-venue">
              <a href="http://www.wgp-sigplan.org/farmer/doku.php?id=2011">Workshop on Generic Programming (WGP)<span class="publication-year">2011</span></a>
            </div>
            <div class="publication-links">
              <span class="label label-warning publication-type">Superseded</span>
              <span class="label label-primary"><a href="https://dl.acm.org/authorize?N21374">PDF (ACM Author-Izer)</a></span>
              <span class="label label-info publication-more-info" data-toggle="collapse" data-target="#OAOAOO">More info</span>
            </div>
          </div>
          <div class="panel panel-publication-info collapse" id="OAOAOO">
            <div class="panel-body">
              <div class="row publication-info">
                <div class="col-sm-2 publication-info-title">
                  Pages
                </div>
                <div class="col-sm-10">
                  13–24
                </div>
              </div>
              <div class="row publication-info">
                <div class="col-sm-2 publication-info-title">
                  DOI
                </div>
                <div class="col-sm-10">
                  <a href="http://dx.doi.org/10.1145/2036918.2036921">10.1145/2036918.2036921</a>
                </div>
              </div>
              <div class="row publication-info">
                <div class="col-sm-2 publication-info-title">
                  Abstract
                </div>
                <div class="col-sm-10">
                  <p>Dependently typed programmers are encouraged to use inductive families to integrate constraints with data construction. Different constraints are used in different contexts, leading to different versions of datatypes for the same data structure. Modular implementation of common operations for these structurally similar datatypes has been a longstanding problem. We propose a datatype-generic solution based on McBride’s datatype ornaments, exploiting an isomorphism whose interpretation borrows ideas from realisability. Relevant properties of the operations are separately proven for each constraint, and after the programmer selects several constraints to impose on a basic datatype and synthesises an inductive family incorporating those constraints, the operations can be routinely upgraded to work with the synthesised inductive family.</p>
                </div>
              </div>
            </div>
          </div>

          <div class="publication">
            <div class="publication-title">
              Algebra of Programming in Agda: Dependent types for relational program derivation
            </div>
            <div class="publication-authors">
              <a href="http://www.iis.sinica.edu.tw/~scm/">Shin-Cheng Mu</a>, Hsiang-Shang Ko, and <a href="http://www.cse.chalmers.se/~patrikj/">Patrik Jansson</a>
            </div>
            <div class="publication-venue">
              <a href="https://www.cambridge.org/core/journals/journal-of-functional-programming">Journal of Functional Programming</a><span class="publication-year">2009</span>
            </div>
            <div class="publication-links">
              <span class="label label-primary"><a href="publications/AoPA-JFP.pdf">PDF (preprint)</a></span>
              <span class="label label-primary"><a href="https://github.com/scmu/aopa">Repository (GitHub)</a></span>
              <span class="label label-info publication-more-info" data-toggle="collapse" data-target="#AoPA-JFP">More info</span>
            </div>
          </div>
          <div class="panel panel-publication-info collapse" id="AoPA-JFP">
            <div class="panel-body">
              <div class="row publication-info">
                <div class="col-sm-2 publication-info-title">
                  Volume
                </div>
                <div class="col-sm-10">
                  19
                </div>
              </div>
              <div class="row publication-info">
                <div class="col-sm-2 publication-info-title">
                  Issue
                </div>
                <div class="col-sm-10">
                  5
                </div>
              </div>
              <div class="row publication-info">
                <div class="col-sm-2 publication-info-title">
                  Pages
                </div>
                <div class="col-sm-10">
                  545–579
                </div>
              </div>
              <div class="row publication-info">
                <div class="col-sm-2 publication-info-title">
                  DOI
                </div>
                <div class="col-sm-10">
                  <a href="http://dx.doi.org/10.1017/S0956796809007345">10.1017/S0956796809007345</a>
                </div>
              </div>
              <div class="row publication-info">
                <div class="col-sm-2 publication-info-title">
                  Abstract
                </div>
                <div class="col-sm-10">
                  <p>Relational program derivation is the technique of stepwise refining a relational specification to a program by algebraic rules. The program thus obtained is correct by construction. Meanwhile, dependent type theory is rich enough to express various correctness properties to be verified by the type checker. We have developed a library, AoPA, to encode relational derivations in the dependently typed programming language Agda. A program is coupled with an algebraic derivation whose correctness is guaranteed by the type system. Two non-trivial examples are presented: an optimisation problem, and a derivation of quicksort where well-founded recursion is used to model terminating hylomorphisms in a language with inductive types.</p>
                </div>
              </div>
            </div>
          </div>

          <div class="publication">
            <div class="publication-title">
              Algebra of Programming using dependent types
            </div>
            <div class="publication-authors">
              <a href="http://www.iis.sinica.edu.tw/~scm/">Shin-Cheng Mu</a>, Hsiang-Shang Ko, and <a href="http://www.cse.chalmers.se/~patrikj/">Patrik Jansson</a>
            </div>
            <div class="publication-venue">
              <a href="http://mpc08.lri.fr">Mathematics of Program Construction (MPC)<span class="publication-year">2008</span></a>
            </div>
            <div class="publication-links">
              <span class="label label-warning publication-type">Superseded</span>
              <span class="label label-primary"><a href="publications/AoPA-MPC.pdf">PDF (preprint)</a></span>
              <span class="label label-info publication-more-info" data-toggle="collapse" data-target="#AoPA-MPC">More info</span>
            </div>
          </div>
          <div class="panel panel-publication-info collapse" id="AoPA-MPC">
            <div class="panel-body">
              <div class="row publication-info">
                <div class="col-sm-2 publication-info-title">
                  LNCS
                </div>
                <div class="col-sm-10">
                  5133
                </div>
              </div>
              <div class="row publication-info">
                <div class="col-sm-2 publication-info-title">
                  Pages
                </div>
                <div class="col-sm-10">
                  268–283
                </div>
              </div>
              <div class="row publication-info">
                <div class="col-sm-2 publication-info-title">
                  DOI
                </div>
                <div class="col-sm-10">
                  <a href="http://dx.doi.org/10.1007/978-3-540-70594-9_15">10.1007/978-3-540-70594-9_15</a>
                </div>
              </div>
              <div class="row publication-info">
                <div class="col-sm-2 publication-info-title">
                  Abstract
                </div>
                <div class="col-sm-10">
                  <p>Dependent type theory is rich enough to express that a program satisfies an input/output relational specification, but it could be hard to construct the proof term. On the other hand, squiggolists know very well how to show that one relation is included in another by algebraic reasoning. We demonstrate how to encode functional and relational derivations in a dependently typed programming language. A program is coupled with an algebraic derivation from a specification, whose correctness is guaranteed by the type system.</p>
                </div>
              </div>
            </div>
          </div>

        </div>
      </div>

      <p class="acknowledgements">Site built with <a href="http://getbootstrap.com">Bootstrap</a> and <a href="https://fonts.google.com/">Google Fonts</a>, and hosted on <a href="https://pages.github.com">GitHub Pages</a>. Special thanks to <a href="http://www.prg.nii.ac.jp/members/zhu/">Zirun Zhu</a> for getting my knowledge of web technology slightly more up to date.</p>

    </div>
    </div>

  </body>
